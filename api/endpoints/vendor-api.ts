/* tslint:disable */
/* eslint-disable */
/**
 * PardoMart Node API
 * API documentation for the PardoMart Node.js application.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@pardomart.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { CreateVendorPayload } from '../models';
// @ts-ignore
import type { DeclineOrderPayload } from '../models';
// @ts-ignore
import type { EarningsTotalGet200Response } from '../models';
// @ts-ignore
import type { Order } from '../models';
// @ts-ignore
import type { OrderItemWithRelations } from '../models';
// @ts-ignore
import type { OrderStatus } from '../models';
// @ts-ignore
import type { PaginatedTrendingVendorProducts } from '../models';
// @ts-ignore
import type { PaginatedVendors } from '../models';
// @ts-ignore
import type { ProductVendorMyProductsGet200Response } from '../models';
// @ts-ignore
import type { ProductVendorTransferPost200Response } from '../models';
// @ts-ignore
import type { ProductVendorTransferPostRequest } from '../models';
// @ts-ignore
import type { Transaction } from '../models';
// @ts-ignore
import type { TransactionWithRelations } from '../models';
// @ts-ignore
import type { UpdateOrderItemShoppingStatusPayload } from '../models';
// @ts-ignore
import type { UpdateVendorPayload } from '../models';
// @ts-ignore
import type { Vendor } from '../models';
// @ts-ignore
import type { VendorListItem } from '../models';
// @ts-ignore
import type { VendorOrder } from '../models';
// @ts-ignore
import type { VendorWithDetails } from '../models';
// @ts-ignore
import type { VendorWithRelations } from '../models';
// @ts-ignore
import type { VendorsIncompleteSetupsGet200Response } from '../models';
/**
 * VendorApi - axios parameter creator
 */
export const VendorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all earnings (vendor payouts) for the authenticated vendor owner. Can be filtered by a specific `vendorId` (store ID) to see earnings for just one store. 
         * @summary List earnings for a vendor
         * @param {string} [vendorId] Optional. Filter earnings for a specific store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        earningsGet: async (vendorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/earnings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calculates and returns the total earnings for the authenticated vendor owner. The total can be filtered by a specific time period. 
         * @summary Get total earnings for a vendor
         * @param {EarningsTotalGetPeriodEnum} [period] Optional. The time period to calculate earnings for. - &#x60;today&#x60;: From the beginning of the current day. - &#x60;7days&#x60;: For the last 7 days. - &#x60;1month&#x60;: For the last 1 month. - &#x60;1year&#x60;: For the last 1 year. If omitted, total earnings of all time are returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        earningsTotalGet: async (period?: EarningsTotalGetPeriodEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/earnings/total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accept a pending order
         * @param {string} orderId The ID of the order to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdAcceptPatch: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdAcceptPatch', 'orderId', orderId)
            const localVarPath = `/order/{orderId}/accept`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Decline a pending order
         * @param {string} orderId The ID of the order to decline.
         * @param {DeclineOrderPayload} [declineOrderPayload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdDeclinePatch: async (orderId: string, declineOrderPayload?: DeclineOrderPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdDeclinePatch', 'orderId', orderId)
            const localVarPath = `/order/{orderId}/decline`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(declineOrderPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the assigned shopper or delivery person to update an item\'s status during shopping (e.g., found, not found, suggest replacement).
         * @summary Update the shopping status of an order item
         * @param {UpdateOrderItemShoppingStatusPayload} updateOrderItemShoppingStatusPayload 
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdItemsItemIdUpdateShoppingStatusPatch: async (updateOrderItemShoppingStatusPayload: UpdateOrderItemShoppingStatusPayload, orderId: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateOrderItemShoppingStatusPayload' is not null or undefined
            assertParamExists('orderOrderIdItemsItemIdUpdateShoppingStatusPatch', 'updateOrderItemShoppingStatusPayload', updateOrderItemShoppingStatusPayload)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdItemsItemIdUpdateShoppingStatusPatch', 'orderId', orderId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('orderOrderIdItemsItemIdUpdateShoppingStatusPatch', 'itemId', itemId)
            const localVarPath = `/order/{orderId}/items/{itemId}/update-shopping-status`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrderItemShoppingStatusPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark an order as \'currently shopping\'
         * @param {string} orderId The ID of the order to start shopping for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdStartShoppingPatch: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdStartShoppingPatch', 'orderId', orderId)
            const localVarPath = `/order/{orderId}/start-shopping`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of orders with role-based access: - **Vendor**: Can see all orders from all their stores. Can filter by `vendorId` and/or `status`. - **Store Admin**: Can only see orders from their assigned store. - **Store Shopper**: Can only see orders assigned to them (`shopperId` matches their user ID) within their store. 
         * @summary Get orders based on user role (Vendor, Store Admin, or Store Shopper)
         * @param {string} [vendorId] Optional. For Vendors, filters orders by a specific store ID. Ignored for staff roles.
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderVendorGet: async (vendorId?: string, status?: OrderStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/vendor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get orders for a vendor\'s dashboard
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderVendorOrdersGet: async (status?: OrderStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/vendorOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a complete list of all vendor-specific products from all stores owned by the authenticated vendor user.
         * @summary Get all products from all stores owned by the authenticated vendor
         * @param {string} [vendorId] Optional. Filter products by a specific store ID owned by the vendor.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorMyProductsGet: async (vendorId?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/vendor/my-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Copies a vendor product listing from a source store to one or more target stores owned by the same vendor. The product will not be transferred to stores where it already exists. 
         * @summary Transfer a product listing from one store to others
         * @param {ProductVendorTransferPostRequest} productVendorTransferPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTransferPost: async (productVendorTransferPostRequest: ProductVendorTransferPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productVendorTransferPostRequest' is not null or undefined
            assertParamExists('productVendorTransferPost', 'productVendorTransferPostRequest', productVendorTransferPostRequest)
            const localVarPath = `/product/vendor/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productVendorTransferPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
         * @summary Get trending vendor products
         * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTrendingGet: async (vendorId?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/vendor/trending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all payment-related transactions for stores owned by the authenticated vendor user. Can be filtered by a specific store.
         * @summary Get payment transactions for a vendor user
         * @param {string} [vendorId] Optional. The ID of a specific store (vendor) to filter payments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsVendorGet: async (vendorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/vendor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of vendors. Can be filtered by name and sorted by proximity if latitude and longitude are provided. If the user is authenticated, it also returns the number of items in their cart for each vendor.
         * @summary Get a paginated list of vendors
         * @param {string} [name] Filter vendors by name (case-insensitive search).
         * @param {number} [latitude] User\&#39;s current latitude to sort vendors by distance.
         * @param {number} [longitude] User\&#39;s current longitude to sort vendors by distance.
         * @param {string} [userId] Filter vendors by the user who owns them.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsGet: async (name?: string, latitude?: number, longitude?: number, userId?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vendors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all vendors associated with the currently authenticated user.
         * @summary Get all vendors for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsGetvendorsbyUserIdGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vendors/getvendorsby/userId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a vendor\'s store as verified by setting `isVerified` to true. This is intended to be an admin-only action. 
         * @summary Approve a vendor\'s store (Admin)
         * @param {string} id The ID of the vendor to approve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdApprovePatch: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('vendorsIdApprovePatch', 'id', id)
            const localVarPath = `/vendors/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a vendor
         * @param {string} id The ID of the vendor to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('vendorsIdDelete', 'id', id)
            const localVarPath = `/vendors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a vendor by its ID
         * @param {string} id The ID of the vendor to retrieve.
         * @param {number} [latitude] User\&#39;s current latitude to calculate distance to the vendor.
         * @param {number} [longitude] User\&#39;s current longitude to calculate distance to the vendor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdGet: async (id: string, latitude?: number, longitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('vendorsIdGet', 'id', id)
            const localVarPath = `/vendors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a vendor\'s details
         * @param {UpdateVendorPayload} updateVendorPayload 
         * @param {string} id The ID of the vendor to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdPatch: async (updateVendorPayload: UpdateVendorPayload, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateVendorPayload' is not null or undefined
            assertParamExists('vendorsIdPatch', 'updateVendorPayload', updateVendorPayload)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('vendorsIdPatch', 'id', id)
            const localVarPath = `/vendors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVendorPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a vendor\'s store as published by setting `isPublished` to true, making it visible to customers. Only the user who owns the vendor can perform this action. 
         * @summary Publish a vendor\'s store
         * @param {string} id The ID of the vendor to publish.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdPublishPatch: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('vendorsIdPublishPatch', 'id', id)
            const localVarPath = `/vendors/{id}/publish`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of vendors for the authenticated user that have not completed their setup. A setup is considered incomplete if the vendor has either not added any products OR has uploaded fewer than two documents. 
         * @summary Find vendors with incomplete setup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIncompleteSetupsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vendors/incomplete-setups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new vendor profile linked to the authenticated user. Default opening hours from 9:00 to 18:00 are created automatically for all days of the week.
         * @summary Create a new vendor
         * @param {CreateVendorPayload} createVendorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsPost: async (createVendorPayload: CreateVendorPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVendorPayload' is not null or undefined
            assertParamExists('vendorsPost', 'createVendorPayload', createVendorPayload)
            const localVarPath = `/vendors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVendorPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VendorApi - functional programming interface
 */
export const VendorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VendorApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of all earnings (vendor payouts) for the authenticated vendor owner. Can be filtered by a specific `vendorId` (store ID) to see earnings for just one store. 
         * @summary List earnings for a vendor
         * @param {string} [vendorId] Optional. Filter earnings for a specific store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async earningsGet(vendorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.earningsGet(vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.earningsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Calculates and returns the total earnings for the authenticated vendor owner. The total can be filtered by a specific time period. 
         * @summary Get total earnings for a vendor
         * @param {EarningsTotalGetPeriodEnum} [period] Optional. The time period to calculate earnings for. - &#x60;today&#x60;: From the beginning of the current day. - &#x60;7days&#x60;: For the last 7 days. - &#x60;1month&#x60;: For the last 1 month. - &#x60;1year&#x60;: For the last 1 year. If omitted, total earnings of all time are returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async earningsTotalGet(period?: EarningsTotalGetPeriodEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EarningsTotalGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.earningsTotalGet(period, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.earningsTotalGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Accept a pending order
         * @param {string} orderId The ID of the order to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdAcceptPatch(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdAcceptPatch(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.orderOrderIdAcceptPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Decline a pending order
         * @param {string} orderId The ID of the order to decline.
         * @param {DeclineOrderPayload} [declineOrderPayload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdDeclinePatch(orderId: string, declineOrderPayload?: DeclineOrderPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdDeclinePatch(orderId, declineOrderPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.orderOrderIdDeclinePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the assigned shopper or delivery person to update an item\'s status during shopping (e.g., found, not found, suggest replacement).
         * @summary Update the shopping status of an order item
         * @param {UpdateOrderItemShoppingStatusPayload} updateOrderItemShoppingStatusPayload 
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdItemsItemIdUpdateShoppingStatusPatch(updateOrderItemShoppingStatusPayload: UpdateOrderItemShoppingStatusPayload, orderId: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdItemsItemIdUpdateShoppingStatusPatch(updateOrderItemShoppingStatusPayload, orderId, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.orderOrderIdItemsItemIdUpdateShoppingStatusPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Mark an order as \'currently shopping\'
         * @param {string} orderId The ID of the order to start shopping for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdStartShoppingPatch(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdStartShoppingPatch(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.orderOrderIdStartShoppingPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of orders with role-based access: - **Vendor**: Can see all orders from all their stores. Can filter by `vendorId` and/or `status`. - **Store Admin**: Can only see orders from their assigned store. - **Store Shopper**: Can only see orders assigned to them (`shopperId` matches their user ID) within their store. 
         * @summary Get orders based on user role (Vendor, Store Admin, or Store Shopper)
         * @param {string} [vendorId] Optional. For Vendors, filters orders by a specific store ID. Ignored for staff roles.
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderVendorGet(vendorId?: string, status?: OrderStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderVendorGet(vendorId, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.orderVendorGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get orders for a vendor\'s dashboard
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderVendorOrdersGet(status?: OrderStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorOrder>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderVendorOrdersGet(status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.orderVendorOrdersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a complete list of all vendor-specific products from all stores owned by the authenticated vendor user.
         * @summary Get all products from all stores owned by the authenticated vendor
         * @param {string} [vendorId] Optional. Filter products by a specific store ID owned by the vendor.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorMyProductsGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVendorMyProductsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorMyProductsGet(vendorId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.productVendorMyProductsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Copies a vendor product listing from a source store to one or more target stores owned by the same vendor. The product will not be transferred to stores where it already exists. 
         * @summary Transfer a product listing from one store to others
         * @param {ProductVendorTransferPostRequest} productVendorTransferPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorTransferPost(productVendorTransferPostRequest: ProductVendorTransferPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVendorTransferPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorTransferPost(productVendorTransferPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.productVendorTransferPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
         * @summary Get trending vendor products
         * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorTrendingGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTrendingVendorProducts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorTrendingGet(vendorId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.productVendorTrendingGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all payment-related transactions for stores owned by the authenticated vendor user. Can be filtered by a specific store.
         * @summary Get payment transactions for a vendor user
         * @param {string} [vendorId] Optional. The ID of a specific store (vendor) to filter payments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsVendorGet(vendorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsVendorGet(vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.transactionsVendorGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of vendors. Can be filtered by name and sorted by proximity if latitude and longitude are provided. If the user is authenticated, it also returns the number of items in their cart for each vendor.
         * @summary Get a paginated list of vendors
         * @param {string} [name] Filter vendors by name (case-insensitive search).
         * @param {number} [latitude] User\&#39;s current latitude to sort vendors by distance.
         * @param {number} [longitude] User\&#39;s current longitude to sort vendors by distance.
         * @param {string} [userId] Filter vendors by the user who owns them.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsGet(name?: string, latitude?: number, longitude?: number, userId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVendors>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsGet(name, latitude, longitude, userId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all vendors associated with the currently authenticated user.
         * @summary Get all vendors for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsGetvendorsbyUserIdGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorListItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsGetvendorsbyUserIdGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsGetvendorsbyUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Marks a vendor\'s store as verified by setting `isVerified` to true. This is intended to be an admin-only action. 
         * @summary Approve a vendor\'s store (Admin)
         * @param {string} id The ID of the vendor to approve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsIdApprovePatch(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsIdApprovePatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsIdApprovePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a vendor
         * @param {string} id The ID of the vendor to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a vendor by its ID
         * @param {string} id The ID of the vendor to retrieve.
         * @param {number} [latitude] User\&#39;s current latitude to calculate distance to the vendor.
         * @param {number} [longitude] User\&#39;s current longitude to calculate distance to the vendor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsIdGet(id: string, latitude?: number, longitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorWithDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsIdGet(id, latitude, longitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a vendor\'s details
         * @param {UpdateVendorPayload} updateVendorPayload 
         * @param {string} id The ID of the vendor to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsIdPatch(updateVendorPayload: UpdateVendorPayload, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsIdPatch(updateVendorPayload, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Marks a vendor\'s store as published by setting `isPublished` to true, making it visible to customers. Only the user who owns the vendor can perform this action. 
         * @summary Publish a vendor\'s store
         * @param {string} id The ID of the vendor to publish.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsIdPublishPatch(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsIdPublishPatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsIdPublishPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of vendors for the authenticated user that have not completed their setup. A setup is considered incomplete if the vendor has either not added any products OR has uploaded fewer than two documents. 
         * @summary Find vendors with incomplete setup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsIncompleteSetupsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorsIncompleteSetupsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsIncompleteSetupsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsIncompleteSetupsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new vendor profile linked to the authenticated user. Default opening hours from 9:00 to 18:00 are created automatically for all days of the week.
         * @summary Create a new vendor
         * @param {CreateVendorPayload} createVendorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsPost(createVendorPayload: CreateVendorPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsPost(createVendorPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VendorApi - factory interface
 */
export const VendorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VendorApiFp(configuration)
    return {
        /**
         * Retrieves a list of all earnings (vendor payouts) for the authenticated vendor owner. Can be filtered by a specific `vendorId` (store ID) to see earnings for just one store. 
         * @summary List earnings for a vendor
         * @param {string} [vendorId] Optional. Filter earnings for a specific store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        earningsGet(vendorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Transaction>> {
            return localVarFp.earningsGet(vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Calculates and returns the total earnings for the authenticated vendor owner. The total can be filtered by a specific time period. 
         * @summary Get total earnings for a vendor
         * @param {EarningsTotalGetPeriodEnum} [period] Optional. The time period to calculate earnings for. - &#x60;today&#x60;: From the beginning of the current day. - &#x60;7days&#x60;: For the last 7 days. - &#x60;1month&#x60;: For the last 1 month. - &#x60;1year&#x60;: For the last 1 year. If omitted, total earnings of all time are returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        earningsTotalGet(period?: EarningsTotalGetPeriodEnum, options?: RawAxiosRequestConfig): AxiosPromise<EarningsTotalGet200Response> {
            return localVarFp.earningsTotalGet(period, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Accept a pending order
         * @param {string} orderId The ID of the order to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdAcceptPatch(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.orderOrderIdAcceptPatch(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Decline a pending order
         * @param {string} orderId The ID of the order to decline.
         * @param {DeclineOrderPayload} [declineOrderPayload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdDeclinePatch(orderId: string, declineOrderPayload?: DeclineOrderPayload, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.orderOrderIdDeclinePatch(orderId, declineOrderPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the assigned shopper or delivery person to update an item\'s status during shopping (e.g., found, not found, suggest replacement).
         * @summary Update the shopping status of an order item
         * @param {UpdateOrderItemShoppingStatusPayload} updateOrderItemShoppingStatusPayload 
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdItemsItemIdUpdateShoppingStatusPatch(updateOrderItemShoppingStatusPayload: UpdateOrderItemShoppingStatusPayload, orderId: string, itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrderItemWithRelations> {
            return localVarFp.orderOrderIdItemsItemIdUpdateShoppingStatusPatch(updateOrderItemShoppingStatusPayload, orderId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark an order as \'currently shopping\'
         * @param {string} orderId The ID of the order to start shopping for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdStartShoppingPatch(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.orderOrderIdStartShoppingPatch(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of orders with role-based access: - **Vendor**: Can see all orders from all their stores. Can filter by `vendorId` and/or `status`. - **Store Admin**: Can only see orders from their assigned store. - **Store Shopper**: Can only see orders assigned to them (`shopperId` matches their user ID) within their store. 
         * @summary Get orders based on user role (Vendor, Store Admin, or Store Shopper)
         * @param {string} [vendorId] Optional. For Vendors, filters orders by a specific store ID. Ignored for staff roles.
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderVendorGet(vendorId?: string, status?: OrderStatus, options?: RawAxiosRequestConfig): AxiosPromise<Array<Order>> {
            return localVarFp.orderVendorGet(vendorId, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get orders for a vendor\'s dashboard
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderVendorOrdersGet(status?: OrderStatus, options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorOrder>> {
            return localVarFp.orderVendorOrdersGet(status, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a complete list of all vendor-specific products from all stores owned by the authenticated vendor user.
         * @summary Get all products from all stores owned by the authenticated vendor
         * @param {string} [vendorId] Optional. Filter products by a specific store ID owned by the vendor.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorMyProductsGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<ProductVendorMyProductsGet200Response> {
            return localVarFp.productVendorMyProductsGet(vendorId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Copies a vendor product listing from a source store to one or more target stores owned by the same vendor. The product will not be transferred to stores where it already exists. 
         * @summary Transfer a product listing from one store to others
         * @param {ProductVendorTransferPostRequest} productVendorTransferPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTransferPost(productVendorTransferPostRequest: ProductVendorTransferPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductVendorTransferPost200Response> {
            return localVarFp.productVendorTransferPost(productVendorTransferPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
         * @summary Get trending vendor products
         * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTrendingGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTrendingVendorProducts> {
            return localVarFp.productVendorTrendingGet(vendorId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all payment-related transactions for stores owned by the authenticated vendor user. Can be filtered by a specific store.
         * @summary Get payment transactions for a vendor user
         * @param {string} [vendorId] Optional. The ID of a specific store (vendor) to filter payments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsVendorGet(vendorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TransactionWithRelations>> {
            return localVarFp.transactionsVendorGet(vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of vendors. Can be filtered by name and sorted by proximity if latitude and longitude are provided. If the user is authenticated, it also returns the number of items in their cart for each vendor.
         * @summary Get a paginated list of vendors
         * @param {string} [name] Filter vendors by name (case-insensitive search).
         * @param {number} [latitude] User\&#39;s current latitude to sort vendors by distance.
         * @param {number} [longitude] User\&#39;s current longitude to sort vendors by distance.
         * @param {string} [userId] Filter vendors by the user who owns them.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsGet(name?: string, latitude?: number, longitude?: number, userId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedVendors> {
            return localVarFp.vendorsGet(name, latitude, longitude, userId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all vendors associated with the currently authenticated user.
         * @summary Get all vendors for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsGetvendorsbyUserIdGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorListItem>> {
            return localVarFp.vendorsGetvendorsbyUserIdGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Marks a vendor\'s store as verified by setting `isVerified` to true. This is intended to be an admin-only action. 
         * @summary Approve a vendor\'s store (Admin)
         * @param {string} id The ID of the vendor to approve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdApprovePatch(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Vendor> {
            return localVarFp.vendorsIdApprovePatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a vendor
         * @param {string} id The ID of the vendor to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VendorWithRelations> {
            return localVarFp.vendorsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a vendor by its ID
         * @param {string} id The ID of the vendor to retrieve.
         * @param {number} [latitude] User\&#39;s current latitude to calculate distance to the vendor.
         * @param {number} [longitude] User\&#39;s current longitude to calculate distance to the vendor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdGet(id: string, latitude?: number, longitude?: number, options?: RawAxiosRequestConfig): AxiosPromise<VendorWithDetails> {
            return localVarFp.vendorsIdGet(id, latitude, longitude, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a vendor\'s details
         * @param {UpdateVendorPayload} updateVendorPayload 
         * @param {string} id The ID of the vendor to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdPatch(updateVendorPayload: UpdateVendorPayload, id: string, options?: RawAxiosRequestConfig): AxiosPromise<VendorWithRelations> {
            return localVarFp.vendorsIdPatch(updateVendorPayload, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks a vendor\'s store as published by setting `isPublished` to true, making it visible to customers. Only the user who owns the vendor can perform this action. 
         * @summary Publish a vendor\'s store
         * @param {string} id The ID of the vendor to publish.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdPublishPatch(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Vendor> {
            return localVarFp.vendorsIdPublishPatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of vendors for the authenticated user that have not completed their setup. A setup is considered incomplete if the vendor has either not added any products OR has uploaded fewer than two documents. 
         * @summary Find vendors with incomplete setup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIncompleteSetupsGet(options?: RawAxiosRequestConfig): AxiosPromise<VendorsIncompleteSetupsGet200Response> {
            return localVarFp.vendorsIncompleteSetupsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new vendor profile linked to the authenticated user. Default opening hours from 9:00 to 18:00 are created automatically for all days of the week.
         * @summary Create a new vendor
         * @param {CreateVendorPayload} createVendorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsPost(createVendorPayload: CreateVendorPayload, options?: RawAxiosRequestConfig): AxiosPromise<VendorWithRelations> {
            return localVarFp.vendorsPost(createVendorPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VendorApi - object-oriented interface
 */
export class VendorApi extends BaseAPI {
    /**
     * Retrieves a list of all earnings (vendor payouts) for the authenticated vendor owner. Can be filtered by a specific `vendorId` (store ID) to see earnings for just one store. 
     * @summary List earnings for a vendor
     * @param {string} [vendorId] Optional. Filter earnings for a specific store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public earningsGet(vendorId?: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).earningsGet(vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calculates and returns the total earnings for the authenticated vendor owner. The total can be filtered by a specific time period. 
     * @summary Get total earnings for a vendor
     * @param {EarningsTotalGetPeriodEnum} [period] Optional. The time period to calculate earnings for. - &#x60;today&#x60;: From the beginning of the current day. - &#x60;7days&#x60;: For the last 7 days. - &#x60;1month&#x60;: For the last 1 month. - &#x60;1year&#x60;: For the last 1 year. If omitted, total earnings of all time are returned. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public earningsTotalGet(period?: EarningsTotalGetPeriodEnum, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).earningsTotalGet(period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Accept a pending order
     * @param {string} orderId The ID of the order to accept.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdAcceptPatch(orderId: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).orderOrderIdAcceptPatch(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Decline a pending order
     * @param {string} orderId The ID of the order to decline.
     * @param {DeclineOrderPayload} [declineOrderPayload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdDeclinePatch(orderId: string, declineOrderPayload?: DeclineOrderPayload, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).orderOrderIdDeclinePatch(orderId, declineOrderPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the assigned shopper or delivery person to update an item\'s status during shopping (e.g., found, not found, suggest replacement).
     * @summary Update the shopping status of an order item
     * @param {UpdateOrderItemShoppingStatusPayload} updateOrderItemShoppingStatusPayload 
     * @param {string} orderId 
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdItemsItemIdUpdateShoppingStatusPatch(updateOrderItemShoppingStatusPayload: UpdateOrderItemShoppingStatusPayload, orderId: string, itemId: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).orderOrderIdItemsItemIdUpdateShoppingStatusPatch(updateOrderItemShoppingStatusPayload, orderId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark an order as \'currently shopping\'
     * @param {string} orderId The ID of the order to start shopping for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdStartShoppingPatch(orderId: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).orderOrderIdStartShoppingPatch(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of orders with role-based access: - **Vendor**: Can see all orders from all their stores. Can filter by `vendorId` and/or `status`. - **Store Admin**: Can only see orders from their assigned store. - **Store Shopper**: Can only see orders assigned to them (`shopperId` matches their user ID) within their store. 
     * @summary Get orders based on user role (Vendor, Store Admin, or Store Shopper)
     * @param {string} [vendorId] Optional. For Vendors, filters orders by a specific store ID. Ignored for staff roles.
     * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderVendorGet(vendorId?: string, status?: OrderStatus, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).orderVendorGet(vendorId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get orders for a vendor\'s dashboard
     * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderVendorOrdersGet(status?: OrderStatus, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).orderVendorOrdersGet(status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a complete list of all vendor-specific products from all stores owned by the authenticated vendor user.
     * @summary Get all products from all stores owned by the authenticated vendor
     * @param {string} [vendorId] Optional. Filter products by a specific store ID owned by the vendor.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorMyProductsGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).productVendorMyProductsGet(vendorId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Copies a vendor product listing from a source store to one or more target stores owned by the same vendor. The product will not be transferred to stores where it already exists. 
     * @summary Transfer a product listing from one store to others
     * @param {ProductVendorTransferPostRequest} productVendorTransferPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorTransferPost(productVendorTransferPostRequest: ProductVendorTransferPostRequest, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).productVendorTransferPost(productVendorTransferPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
     * @summary Get trending vendor products
     * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorTrendingGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).productVendorTrendingGet(vendorId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all payment-related transactions for stores owned by the authenticated vendor user. Can be filtered by a specific store.
     * @summary Get payment transactions for a vendor user
     * @param {string} [vendorId] Optional. The ID of a specific store (vendor) to filter payments for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsVendorGet(vendorId?: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).transactionsVendorGet(vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of vendors. Can be filtered by name and sorted by proximity if latitude and longitude are provided. If the user is authenticated, it also returns the number of items in their cart for each vendor.
     * @summary Get a paginated list of vendors
     * @param {string} [name] Filter vendors by name (case-insensitive search).
     * @param {number} [latitude] User\&#39;s current latitude to sort vendors by distance.
     * @param {number} [longitude] User\&#39;s current longitude to sort vendors by distance.
     * @param {string} [userId] Filter vendors by the user who owns them.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsGet(name?: string, latitude?: number, longitude?: number, userId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsGet(name, latitude, longitude, userId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all vendors associated with the currently authenticated user.
     * @summary Get all vendors for the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsGetvendorsbyUserIdGet(options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsGetvendorsbyUserIdGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a vendor\'s store as verified by setting `isVerified` to true. This is intended to be an admin-only action. 
     * @summary Approve a vendor\'s store (Admin)
     * @param {string} id The ID of the vendor to approve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsIdApprovePatch(id: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsIdApprovePatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a vendor
     * @param {string} id The ID of the vendor to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a vendor by its ID
     * @param {string} id The ID of the vendor to retrieve.
     * @param {number} [latitude] User\&#39;s current latitude to calculate distance to the vendor.
     * @param {number} [longitude] User\&#39;s current longitude to calculate distance to the vendor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsIdGet(id: string, latitude?: number, longitude?: number, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsIdGet(id, latitude, longitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a vendor\'s details
     * @param {UpdateVendorPayload} updateVendorPayload 
     * @param {string} id The ID of the vendor to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsIdPatch(updateVendorPayload: UpdateVendorPayload, id: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsIdPatch(updateVendorPayload, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a vendor\'s store as published by setting `isPublished` to true, making it visible to customers. Only the user who owns the vendor can perform this action. 
     * @summary Publish a vendor\'s store
     * @param {string} id The ID of the vendor to publish.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsIdPublishPatch(id: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsIdPublishPatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of vendors for the authenticated user that have not completed their setup. A setup is considered incomplete if the vendor has either not added any products OR has uploaded fewer than two documents. 
     * @summary Find vendors with incomplete setup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsIncompleteSetupsGet(options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsIncompleteSetupsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new vendor profile linked to the authenticated user. Default opening hours from 9:00 to 18:00 are created automatically for all days of the week.
     * @summary Create a new vendor
     * @param {CreateVendorPayload} createVendorPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsPost(createVendorPayload: CreateVendorPayload, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsPost(createVendorPayload, options).then((request) => request(this.axios, this.basePath));
    }
}

export const EarningsTotalGetPeriodEnum = {
    Today: 'today',
    _7days: '7days',
    _1month: '1month',
    _1year: '1year'
} as const;
export type EarningsTotalGetPeriodEnum = typeof EarningsTotalGetPeriodEnum[keyof typeof EarningsTotalGetPeriodEnum];
